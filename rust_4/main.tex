% Skip over this boring header down a bit
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[usenames,dvipsnames,10pt,aspectratio=169]{beamer} 
% Add option 'aspectratio=169' for 16:9 widescreen 
% Add option  'handout' to ignore animations
% If you have a smaller amount of text, feel free to also try '11pt'! / Jesper

\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\usepackage{minted}
\usemintedstyle{monokai}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[document]{ragged2e}
\usetheme{umu}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=ucuyellow,
    filecolor=ucuyellow,      
    urlcolor=ucuyellow,
}
\urlstyle{same}

\usepackage[shortlabels]{enumitem}

%%% Bibliography
\usepackage[style=authoryear,backend=biber]{biblatex}
\addbibresource{bibliography.bib}

\DeclareNameAlias{author}{given-family}

%%% Suppress biblatex annoying warning
\usepackage{silence}
\WarningFilter{biblatex}{Patching footnotes failed}

%%% Some useful commands
% pdf-friendly newline in links
\newcommand{\pdfnewline}{\texorpdfstring{\newline}{ }} 
% Fill the vertical space in a slide (to put text at the bottom)
\newcommand{\framefill}{\vskip0pt plus 1filll}

%%% Enter additional packages below 
\renewcommand{\proofname}{\sffamily{Proof}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title[Rust \#4]{Rust \#4: Smart pointers,\\ \vspace{0.1cm}Concurrency and Async}
\author[Sultanov Andriy]{Sultanov Andriy}
\institute{APPS@UCU}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{\contentsname}
\tableofcontents
\end{frame}

\framepic{graphics/7.jpg}{
 \textcolor{ucuwhite}{Smart pointers}
 \vskip 0.5cm
 }

\section{Smart pointers}

\begin{frame}{Smart pointers}
	\framesubtitle{General}
\large	
Rust standard library has a few useful smart pointers:
\vspace{0.4cm}
\begin{itemize}[label=$\bullet$]
	\item Box<T>
	\item Rc<T>
	\item Cell<T>
	\item RefCell<T>
\end{itemize}
\end{frame}

\begin{frame}{Box<T>}
	\large
	Boxes are Rust's way to store data on the heap.\\
	\vspace{0.4cm}
	They are useful when you want to handle values whose\\
	sizes can not be known at compile time as if their size\\
	was known. This works since the size of the pointer to\\
	the heap that the Box keeps on the stack is known.\\
\end{frame}

\begin{frame}{Box<T>}
	\large
	An example of moving a type that is typically stored\\
	on the stack onto the heap:
	\vspace{0.4cm}
	\inputminted[fontsize=\large]{rust}{code/box1.rs}
	\vspace{0.4cm}
	The value is going to be deallocated once it goes out\\
	scope, calling Box's \textcolor{ucuyellow}{drop} implementation.\\
\end{frame}

\begin{frame}{Box<T>}
	\large
	We could have just as well explicitly dereferenced the Box:
	\vspace{0.4cm}
	\inputminted[fontsize=\large]{rust}{code/box2.rs}
\end{frame}

\begin{frame}{Smart pointers}
	\framesubtitle{Deref trait}
	\large
Implementing \textcolor{ucuyellow}{Deref} allows Rust to treat smart\\
pointers as references to the values they hold.\\
\vspace{0.4cm}
You can dereference types impementing \textcolor{ucuyellow}{Deref}\\
explicitly using the \textcolor{ucuyellow}{*} operator, or you can omit\\
the dereferencing and let Rust implicitly coerce\\
your type to the type you need.\\
\vspace{0.4cm}
Thus, when calling a method on a type that\\
implements \textcolor{ucuyellow}{Deref} and does not implement the\\
method, Rust will recursively dereference this\\
type until it finds the appropriate method.
\end{frame}

\begin{frame}{Smart pointers}
	\framesubtitle{Deref trait}
	\large
	Rust will coerce types according to these rules:
	
\begin{itemize}[label=$\bullet$]
	\item From \textcolor{ucuyellow}{\&T} to 
		\textcolor{ucuyellow}{\&U} when 
		\textcolor{ucuyellow}{T: Deref<Target=U>}
	\item From \textcolor{ucuyellow}{\&mut T} to
		\textcolor{ucuyellow}{\&mut U} when 
		\textcolor{ucuyellow}{T: DerefMut<Target=U>}
	\item From \textcolor{ucuyellow}{\&mut T} to
		\textcolor{ucuyellow}{\&U} when
		\textcolor{ucuyellow}{T: Deref<Target=U>}
\end{itemize}
\end{frame}

\begin{frame}{Box<T>}
	\large
	If you want to create an unsized data structure, for\\
	example a recursive cons list, you can just use Box:
	\vspace{0.4cm}
	\inputminted[fontsize=\normalsize]{rust}{code/box3.rs}
	\vspace{0.2cm}
	What will end up being stored is an \textcolor{ucuyellow}{i32} and a\\
	pointer \textcolor{ucuyellow}{usize} to another List on the heap.
\end{frame}

\begin{frame}{Sized}
	Boxes can also be useful if your function takes\\
	a trait object as a parameter (which can't possibly\\
	have its size known at compile time).\\
	\textcolor{ucured}{TODO}
\end{frame}

\begin{frame}{Rc<T>}
	\large
	\textcolor{ucured}{TODO}
\end{frame}

\begin{frame}{Cell<T>}
	\large
	\textcolor{ucured}{TODO}
\end{frame}

\begin{frame}{RefCell<T>}
	\large
	\textcolor{ucured}{TODO}
\end{frame}

\framepic{graphics/7.jpg}{
 \textcolor{ucuwhite}{Concurrency}
 \vskip 0.5cm
 }

\section{Concurrency}

\begin{frame}{Concurrency}
	\large
	\textcolor{ucured}{TODO: Talk about Arc, Mutex,
	mspc, and the way Rust's system prevents data races at compile
time.}
\end{frame}

\framepic{graphics/7.jpg}{
 \textcolor{ucuwhite}{Async}
 \vskip 0.5cm
 }

\section{Async}

\begin{frame}{Async}
	\large
	Rust has, relatively recently, finally settled with its\\
	asynchronous implementation. We do not have the time to\\
	cover all the details of its implementation, and therefore\\
	its history and efficiency, however, we will see the ease\\
	with which your Rust programs can become asynchronous.\\
	\textcolor{ucured}{TODO: talk about runtimes, executors,
	reactors, libraries, futures, async, await, closures etc.}
	
\end{frame}

\framepic{graphics/7.jpg}{
 \textcolor{ucuwhite}{Looking back}
 \vskip 0.5cm
 }

\section{Looking back}

\begin{frame}{Looking back}
	\large
\textcolor{ucured}{TODO: Having learned these powerful abstractions
and techniques blah blah blah}
	
\end{frame}

\framepic{graphics/7.jpg}{
 \textcolor{ucuwhite}{And ahead...}
 \vskip 0.5cm
 }

\section{And ahead...}

\begin{frame}{Looking back}
	\large
\textcolor{ucured}{TODO: We haven't covered quite a lot of important
stuff in Rust. Here are some pointers on what you could do and 
where you should probably look}
	
\end{frame}

\framepic{graphics/7.jpg}{
	\textcolor{ucuwhite}{Thank you!}
 \vskip 0.5cm
 }

\end{document}
